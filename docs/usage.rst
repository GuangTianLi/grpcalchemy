=====
Usage
=====

To use gRPCAlchemy in a project:

.. code-block:: python

    from grpcalchemy.orm import Message, StringField
    from grpcalchemy import Server, Context

    app = Server('server')

    class HelloMessage(Message):
        __filename__ = 'hello'
        name = StringField()

    @app.register
    def test(request: HelloMessage, context: Context) -> HelloMessage:
        return HelloMessage(name=f'Hello {request.name}')

    if __name__ == '__main__':
        app.run()


Defining our Message
===================================

Any message which is used in RPC method must have a explicit schema. We can
use py files generated by proto files by the grpc_tools straightly. However
defining the schemas by our ORM can help to iron out bugs involving incorrect
types or missing fields, and also allow us to define utility methods on our message
in the same way that traditional ORMs do.

In our Tutorial Application we need to send several different types of
message. We will need to have a collection of **users**, so that we may
link posts to an individual. We also need to send our different types of
**posts** (eg: text, image and link) in the RPC method. To aid navigation of our
Tutorial Application, posts may have **tags** associated with them, so that the list of
posts shown to the user may be limited to posts that have been assigned a
specific tag. Finally, it would be nice if **comments** could be added to
posts. We'll start with **users**, as the other document models are slightly
more involved.

Users
-----

Just as if we were using a RPC Message with an ORM, we need to define
which fields a :class:`User` may have, and what types of data they might have:

.. code-block:: python

    class User(Message):
        email = StringField()
        first_name = StringField()
        last_name = StringField()

Posts, Comments and Tags
------------------------

Now we'll think about how to define the rest of the information. To associate the comments
with individual posts, We'd also need a link message to provide the
many-to-many relationship between posts and tags.

Posts
^^^^^

We can think of :class:`Post` as a base class, and :class:`TextPost`, :class:`ImagePost` and
:class:`LinkPost` as subclasses of :class:`Post`.

.. code-block:: python

    class Post(Message):
        title = StringField()
        author = ReferenceField(User)

    class TextPost(Post):
        content = StringField()

    class ImagePost(Post):
        image_path = StringField()

    class LinkPost(Post):
        link_url = StringField()

We are storing a reference to the author of the posts using a
:class:`~grpcalchemy.orm.ReferenceField` object. These are equal to use other
message types in RPC message.

Tags
^^^^

Now that we have our Post models figured out, how will we attach tags to them?
RPC message allows us to define lists of items natively. So, for both
efficiency and simplicity's sake, we'll define the tags as strings directly
within the post. Let's take a look at the code of our modified :class:`Post` class:

.. code-block:: python

    class Post(Message):
        title = StringField()
        author = ReferenceField(User)
        tags = ListField(StringField)

The :class:`~grpcalchemy.orm.ListField` object that is used to define a Post's tags
takes a field object as its first argument --- this means that you can have
lists of any type of field (including lists).

.. note:: We don't need to modify the specialized post types as they all
    inherit from :class:`Post`.

Comments
^^^^^^^^

A comment is typically associated with *one* post.utility methods,
in exactly the same way we do with regular documents:

.. code-block:: python

    class Comment(Message):
        content = StringField()
        name = StringField()

We can then define a list of comment documents in our post message:

.. code-block:: python

    class Post(Document):
        title = StringField()
        author = ReferenceField(User)
        tags = ListField(StringField)
        comments = ListField(Comment)

Defining our gRPC Method
===================================

The ``valid registered function`` must be with `explicit type hint <https://www.python.org/dev/peps/pep-0484/#type-definition-syntax>`_
to define the type of request and return value.

.. code-block:: python

    app = Server('hello')

    @app.register
    def test(request: HelloMessage, context: Context) -> HelloMessage: ...

The above code is equal to an RPC service with a method::

    syntax = "proto3";

    service hello {
        rpc test (HelloMessage) returns (HelloMessage) {
        }
    }


Using Blueprint to Construct Your Large Application
=========================================================

gRPCAlchemy uses a concept of blueprints for making gRPC services and
supporting common patterns within an application or across applications.
:any:`Blueprint` can greatly simplify how large applications work.

.. code-block:: python

    from grpcalchemy.orm import Message, StringField
    from grpcalchemy import Server, Context, Blueprint

    app = Server('server')

    first_blueprint = Blueprint('first_blueprint')

    class HelloMessage(Message):
        __filename__ = 'hello'
        name = StringField()

    @first_blueprint.register
    def test(request: HelloMessage, context: Context) -> HelloMessage:
        return HelloMessage(name=f'Hello {request.name}')

    if __name__ == '__main__':
        app.register_blueprint(first_blueprint)
        app.run()


How to Use the Config
==============================================

Using :any:`Config` to construct your config.

* Priority: *env > local config file > remote center > project config*

Define the Base Config Class
-----------------------------------------

Using `Class` to define your config value explicitly and pass it to :any:`Config` to init:

* `BaseConfig` should define all config used in the project *explicitly* and initialize it.
* the config key should be **uppercase**.

.. code-block:: python

    from grpcalchemy.config import Config

    class BaseConfig:
        DEBUG = False
        TESTING = False
        DATABASE_URI = 'sqlite:///:memory:'

    class ProductionConfig(BaseConfig):
        DATABASE_URI = 'mysql://user@localhost/foo'

    class DevelopmentConfig(BaseConfig):
        DEBUG = True

    class TestingConfig(BaseConfig):
        TESTING = True

    config = Config(obj='configmodule.ProductionConfig')
    # or
    config = Config(obj=ProductionConfig)

Using environment variables explicitly
----------------------------------------
Defining the `ENV_PREFIX` to load the environment variables:

* The :any:`Config` will try to load all `ENV_PREFIX` + `attributes name`.

.. code-block:: python

    from grpcalchemy.config import Config
    import os

    os.environ['TEST_NAME'] = 'env'

    class BaseConfig:
        ENV_PREFIX = 'TEST_'
        NAME = 'base'

    config = Config(obj=BaseConfig)

    >>> config['NAME']
    env

Using the config file explicitly
---------------------------------
Defining the `CONFIG_FILE` to load the environment variables:

.. code-block:: python

    from grpcalchemy.config import Config

    class BaseConfig:
        CONFIG_FILE = 'test.json' #: etc: {'NAME': 'json'}
        NAME = 'base'

    config = Config(obj=BaseConfig)

    >>> config['NAME']
    json

Using the Custom way to Access Config
-------------------------------------------
Using  `sync_access_config_list` or `async_access_config_list` access your config:

.. code-block:: python

    from grpcalchemy.config import Config

    async def get_config_async() -> dict:
        return {'TYPE': 'async'}


    def get_config() -> dict:
        return {'NAME': 'sync'}


    class BaseConfig:
        TYPE = 'base'
        NAME = 'base'


    config = Config(
        obj=BaseConfig,
        sync_access_config_list=[get_config],
        async_access_config_list=[get_config_async])

    >>> config['TYPE']
    async
    >>> config['NAME']
    sync


